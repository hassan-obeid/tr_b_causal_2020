---
jupyter:
  jupytext:
    formats: ipynb,md
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.2'
      jupytext_version: 1.3.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

# Importing packages 

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from functools import reduce
import seaborn as sns

import scipy.stats
import random
from fitter import Fitter
import attr

from causalgraphicalmodels import CausalGraphicalModel, StructuralCausalModel
from collections import OrderedDict
# Local package
import MNL_estimation as MNL

import pylogit as pl
```

# Define the necessary functions

```python
def CreateChoiceDF(*argv):
    """
    Function that generates a dataframe object for all desired variables.
    Input:
    ------
    Series of tuples showing the variable and desired variable name
    in the output dataframe.
    Example, if the user desired to created a dataframe with 2 variables,
    the function should be called as follows:
    df = CreateChoiceDF(("var1_name", var1),("var2_name", var2))  
    Output:
    -------
    DataFrame object
    """
    data_dict = dict()
    for arg in argv:
        data_dict[arg[0]] = arg[1]
    sample_data = pd.DataFrame(data_dict)
    return sample_data

def SimulateChoices(data, alt_id_col, obs_id_col, number_alts, spec_dic, names_dic, init_betas):

# This commented out block is to extend the capabilities of the function from simulating choices
# only based on long data to wide data. The logic is built out completely, all we need is to 
# refactor it and adjust the parameters in the function definition.
#     choice_var = 'choice'
#     custom_alt_id = "alternative_id"
#     obs_id_column = "custom_id"

#     # Adding a Choice Variable Column
#     data[choice_var] = np.random.randint(1, high=number_alts+1, size=data.shape[0])
#     availability_variables = dict()

#     # Adding availability variables and specifying alternative availability numbers
#     for alt in np.arange(1, number_alts+1, 1):
#         data['AV_' + str(alt)] = 1
#         availability_variables[alt] = 'AV_' + str(alt)

#     # Specifying the Individual Variables
#     ind_variables = ind_variables

#     alt_varying_variables = alt_var_vars
#     # Specifying the column heading for the alternative id column in the
#     # long format dataset
#     custom_alt_id = "alternative_id"
#     obs_id_column = "custom_id"
#     sample_data[obs_id_column] = np.arange(sample_data.shape[0],
#                                            dtype=int) + 1

#     # Create a variable recording the choice column

#     long_data = pl.convert_wide_to_long(wide_data=sample_data,
#                                         ind_vars=ind_variables,
#                                         alt_specific_vars=alt_varying_variables,
#                                         availability_vars=availability_variables,
#                                         obs_id_col=obs_id_column,
#                                         choice_col=choice_var,
#                                         new_alt_id_name=custom_alt_id)
    sim_choice_var = 'sim_choice'
    # Functions to generate the probabilities for each alternative

    long_data = data

    design_matrix, names = create_design_matrix(df_long=long_data,
                                                specification_dict=mnl_specification,
                                                names_dict=mnl_names,
                                                alternative_id_col=alt_id_col)
    mapping_matrix = create_mapping_matrix(df_long=long_data,
                                           observation_id_col=obs_id_col)
    probabilities = calculate_probabilities(betas=initial_betas,
                                            design_matrix=design_matrix,
                                            mapping_matrix=mapping_matrix)

    data['probabilities'] = probabilities
    data['cum_sum'] = 0
    data['sim_choice'] = 0

    for observation in data['observation_id'].unique():
        probs_sum = data[data.observation_id==observation]['probabilities'].cumsum()
        data.loc[data['observation_id']==observation,'cum_sum'] = probs_sum

    observation_id_list = list(data.observation_id.unique())
    u_random = np.random.uniform(size = len(data['observation_id'].unique()))

    for u,obs in zip(u_random,observation_id_list):
        data_sample = data[data['observation_id']==obs]
        sorted_list = sorted(list(data_sample['mode_id'].unique()))
        choices = dict.fromkeys(sorted_list, 0)
        for alt in sorted_list:   
            choices[alt] = np.where(u<=data_sample[data_sample['mode_id']==alt]['cum_sum'], 1, 0).item()
            if choices[alt] == 1:
                break
        data.loc[data.observation_id==obs,'sim_choice'] = data['mode_id'].map(choices)
    return data
```

# Example Application 


## Reading and Cleaning Data 

```python
BATS = pd.read_excel('dataModelWide02.xlsx')
```

```python
# Cleaning Data, dropping unreported values and 
# assigning random income within each respective range
BATS_IND = BATS.drop_duplicates(subset='personID').reset_index(drop=True)

BATS_IND = BATS_IND[(BATS_IND.HHINCOME!=98)&(BATS_IND.HHINCOME!=99)]
BATS_IND = BATS_IND[(BATS_IND.HHBICYC!=98)&(BATS_IND.HHBICYC!=99)]
BATS_IND = BATS_IND[(BATS_IND.HHMCYCLE!=98)&(BATS_IND.HHMCYCLE!=99)]
BATS_IND = BATS_IND[(BATS_IND.DWELLTYP!=998)&(BATS_IND.DWELLTYP!=999)]
BATS_IND = BATS_IND[(BATS_IND.HHPHONES!=98)&(BATS_IND.HHPHONES!=99)]
BATS_IND = BATS_IND[(BATS_IND.INTERNM1!=8)&(BATS_IND.INTERNM1!=9)]
BATS_IND = BATS_IND[(BATS_IND.INTERNM2!=8)&(BATS_IND.INTERNM2!=9)]
BATS_IND = BATS_IND[(BATS_IND.GENDER!=8)&(BATS_IND.GENDER!=9)]
BATS_IND = BATS_IND[(BATS_IND.AGE!=998)&(BATS_IND.AGE!=999)&(BATS_IND.AGE!=997)]
BATS_IND = BATS_IND[(BATS_IND.NUMJOBS!=98)&(BATS_IND.NUMJOBS!=99)]
BATS_IND = BATS_IND[(BATS_IND.EMPSTATU!=8)&(BATS_IND.EMPSTATU!=9)]
BATS_IND = BATS_IND[(BATS_IND.EMPTYPE!=8)&(BATS_IND.EMPTYPE!=9)]
BATS_IND = BATS_IND[(BATS_IND.SCHAMT!=8)&(BATS_IND.SCHAMT!=9)]
BATS_IND = BATS_IND[(BATS_IND.SCHTYP!=998)&(BATS_IND.SCHTYP!=999)]
BATS_IND = BATS_IND[(BATS_IND.DISTYPE!=998)&(BATS_IND.DISTYPE!=999)]
BATS_IND = BATS_IND[(BATS_IND.ETHNIC!=998)&(BATS_IND.ETHNIC!=999)].reset_index(drop=True)

BATS_IND['income'] = BATS_IND.HHINCOME.apply(
                                            lambda x: random.randrange(0,15000,10)if x==1 else
                                                     (random.randrange(10000,15000,10)if x==2 else 
                                                     (random.randrange(15000,20000,10)if x==3 else
                                                     (random.randrange(20000,25000,10)if x==4 else
                                                     (random.randrange(25000,30000,10)if x==5 else
                                                     (random.randrange(30000,35000,10)if x==6 else
                                                     (random.randrange(35000,40000,10)if x==7 else
                                                     (random.randrange(40000,45000,10)if x==8 else
                                                     (random.randrange(45000,50000,10)if x==9 else
                                                     (random.randrange(50000,60000,10)if x==10 else
                                                     (random.randrange(60000,75000,10)if x==11 else
                                                     (random.randrange(75000,100000,10)if x==12 else
                                                     (random.randrange(100000,125000,10)if x==13 else
                                                     (random.randrange(125000,150000,10)if x==14 else
                                                      random.randrange(150000,250000,10)))))))))))))))
BATS_IND = BATS_IND[BATS_IND['income']!= 0]
```

## Generate Variables 

```python
age = BATS_IND.AGE.values
income = BATS_IND.income.values
income_div = income/100000
tt_DA = np.abs(np.sqrt(age) + 500000/income + np.random.normal(0, 1, BATS_IND.shape[0]))
tt_TR = np.abs(2.5*age + 40000/np.sqrt(income) + np.random.normal(0, 1, BATS_IND.shape[0]))
tt_BS = np.abs(1.5*age + 500000/income + np.random.normal(0, 1, BATS_IND.shape[0]))
cost_DA = np.abs(10*tt_DA + np.random.normal(0, 1, BATS_IND.shape[0]))
cost_TR = np.abs(tt_TR/100 + np.random.normal(0, 1, BATS_IND.shape[0]))
cost_BS = np.abs(0.25*tt_BS + np.random.normal(0, 1, BATS_IND.shape[0]))
```

## Generate dataset based on assumed Causal Graph

```python
sample_data = CreateChoiceDF(("age", age),
                             ("income", income_div),
                             ("tt_DA", tt_DA),
                             ("tt_BS", tt_BS),
                             ("tt_TR", tt_TR),
                             ("cost_DA", cost_DA),
                             ("cost_BS", cost_BS),
                             ("cost_TR", cost_TR)
                            )
```

## Setting Alternative Varying Variables

```python
ind_variables = ['income','age']
alt_varying_variables = {'Cost': dict([(1, 'cost_TR'),
                                       (2, 'cost_DA'),
                                       (3, 'cost_BS')]),
                         'Travel_Time': dict([(1, 'tt_TR'),
                                              (2, 'tt_DA'),
                                              (3, 'tt_BS')]),
                        }
```

## Setting the specification fo the utility equation

```python
model_specification = OrderedDict()
model_names = OrderedDict()

model_specification['intercept'] = [2,3] ## Which utility equation does the variable enter
model_names['intercept'] = ['ASC_DA', 'ASC_BS']

model_specification['income'] = [1,2,3] ## Which utility equation does the variable enter
model_names['income'] = ['income_TR', 'income_DA', 'income_BS']

model_specification['age'] = [1,2,3] ## Which utility equation does the variable enter
model_names['age'] = ['age_TR', 'age_DA', 'age_BS']

model_specification['Cost'] = [1,2,3] ## Which utility equation does the variable enter
model_names['Cost'] = ['cost_TR', 'cost_DA', 'cost_BS']

model_specification['Travel_Time'] = [1,2,3] ## Which utility equation does the variable enter
model_names['Travel_Time'] = ['tt_TR', 'tt_DA', 'tt_BS']
```

## Intial model parameters

```python
initial_betas= [2, 3, # ASC
                -1, .5, -.2,  # income
                .8, .3, .5, # age
                -.4, -.2, -.04, # cost
                -.5, -.05, -.04, # travel time
                ]
```

# Simulate Choices 

```python
data = SimulateChoices(sample_data,
                       ind_variables,
                       alt_varying_variables,
                       3,
                       model_specification,
                       model_names,
                       initial_betas)
```

```python
causal_model = StructuralCausalModel({
    "age": lambda     n_samples: data.age,
    "income": lambda  n_samples: data.income,
    "Tt_DA": lambda age,income, n_samples: data.tt_DA,
    "Tt_BS": lambda age,income, n_samples: data.tt_BS,
    "Tt_TR": lambda age,income, n_samples: data.tt_TR,
    "Cost_DA": lambda age,income, n_samples: data.cost_DA,
    "Cost_BS": lambda age,income, n_samples: data.cost_BS,
    "Cost_TR": lambda age,income, n_samples: data.cost_TR,
    "mode_choice": lambda age,income,Tt_DA,Tt_BS,Tt_TR,Cost_DA,Cost_BS,Cost_TR, n_samples: data.choice
})
causal_model.cgm.draw()
```
